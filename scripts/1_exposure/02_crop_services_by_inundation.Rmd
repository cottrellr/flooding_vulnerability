---
title: "cropping services by inundation area"
author: "Rich Cottrell"
date: '2023-06-05'
output: html_document
---


```{r}
library(tidyverse)
library(sf)
library(here)
library(rmapshaper)
```


Pull in full flood awareness map. Simplify and reduce buffer around lines to zero

```{r}

flood_awareness <- 
  st_read(here("data/spatial/Flood__Awareness__Extents/Flood___Awareness___Extents.shp")) |> 
  ms_simplify(keep=0.05) |> 
  st_buffer(dist = 0)


ggplot()+
  geom_sf(data = flood_awareness, size=NA, fill="hotpink")

```


Petrol stations

```{r}

#Aus petrol stations
petrol_stations <- 
  st_read(here("data/spatial/Petrol_Stations_Australia_new/PetrolStations.gdb")) |> 
  st_transform(crs = st_crs(flood_awareness))

#filter for Brisbane
bris_petrol_stations <- petrol_stations |> st_crop(flood_awareness) |>  mutate(row_num = row_number())

# split the petrol stations for iteration
bris_petrol_split <- bris_petrol_stations |> group_by(row_num) |> group_split()
length(bris_petrol_split)

#test function
this_petrol_station <- bris_petrol_split[[10]]

#define cores
cores <- parallel::detectCores()/2

#setup the session
future::plan(future::multisession, workers = cores)

#create list of buffered shapefiles
petrol_intersect <- 
  
  furrr::future_map(.x = bris_petrol_split, .f = \(this_petrol_station){
  
    message("processing petrol station ", this_petrol_station$row_num, " / ", bris_petrol_stations |> nrow())
  
    this_station_intersect <- st_intersection(this_petrol_station, flood_awareness)
    
    this_station_classify <- this_petrol_station |> 
      mutate(inundation = case_when(nrow(this_station_intersect)>0 ~ "Inundated",
                                    TRUE ~ "Not inundated"))
    
}) |> bind_rows()

#filter by those not inundated
petrol_not_inundated <- petrol_intersect |> filter(inundation== "Not inundated")


#write the shapefile
st_write(petrol_not_inundated, here("data/spatial/petrol_stations_not_inundated/petrol_stations_not_inundated.shp"))







```

