---
title: "cropping services by inundation area"
author: "Rich Cottrell"
date: '2023-06-05'
output: html_document
---


```{r}
library(tidyverse)
library(sf)
library(here)
library(rmapshaper)
library(janitor)
```


Pull in full flood awareness map. Simplify and reduce buffer around lines to zero

```{r}

flood_awareness <- 
  st_read(here("data/spatial/Flood__Awareness__Extents/Flood___Awareness___Extents.shp")) |> 
  ms_simplify(keep=0.05) |> 
  st_buffer(dist = 0)


ggplot()+
  geom_sf(data = flood_awareness, size=NA, fill="hotpink")

```


Petrol stations

```{r}

#Aus petrol stations
petrol_stations <- 
  st_read(here("data/spatial/Petrol_Stations_Australia_new/PetrolStations.gdb")) |> 
  st_transform(crs = st_crs(flood_awareness))

#filter for Brisbane
bris_petrol_stations <- petrol_stations |> st_crop(flood_awareness) |>  mutate(row_num = row_number())

# split the petrol stations for iteration
bris_petrol_split <- bris_petrol_stations |> group_by(row_num) |> group_split()
length(bris_petrol_split)

#test function
this_petrol_station <- bris_petrol_split[[10]]

#define cores
cores <- parallel::detectCores()/2

#setup the session
future::plan(future::multisession, workers = cores)

#create list of buffered shapefiles
petrol_intersect <- 
  
  furrr::future_map(.x = bris_petrol_split, .f = \(this_petrol_station){
  
    message("processing petrol station ", this_petrol_station$row_num, " / ", bris_petrol_stations |> nrow())
  
    this_station_intersect <- st_intersection(this_petrol_station, flood_awareness)
    
    this_station_classify <- this_petrol_station |> 
      mutate(inundation = case_when(nrow(this_station_intersect)>0 ~ "Inundated",
                                    TRUE ~ "Not inundated"))
    
    return(this_station_classify)
    
}) |> bind_rows()

#filter by those not inundated
petrol_not_inundated <- petrol_intersect |> filter(inundation== "Not inundated")


#write the shapefile
st_write(petrol_not_inundated, here("data/spatial/not_inundated_petrol_stations/petrol_stations_not_inundated.shp"))


```


Identify non-inundated hospitals

```{r}

hospital_shp <- read_csv(here("data/raw_data/Brisbane_hospital.csv")) |> 
  clean_names() |> 
  drop_na(longitude, latitude) |> 
  st_as_sf(coords = c("longitude", "latitude"), crs = "EPSG:4326") |> 
  st_transform(crs = st_crs(flood_awareness)) |> 
  st_crop(st_bbox(flood_awareness))

#check they are in the same crs
st_crs(flood_awareness)
st_crs(hospital_shp)

ggplot()+
  geom_sf(data = flood_awareness, fill = "lightblue", linewidth = 0.01) +
  geom_sf(data = hospital_shp, colour = "red")+
  theme_bw()

hospital_shp_list <- hospital_shp |> group_by(hospital_name) |> group_split()

this_hospital <- hospital_shp_list[[1]]

hospital_inundation_df <- 
  
  map_df(hospital_shp_list, .f= \(this_hospital){
    
  this_hospital_name <- this_hospital$hospital_name
  
  message("Processing - ", this_hospital_name )
  
  inundated_hospital <- st_intersection(this_hospital, flood_awareness)
  
  inundated_or_not <- if_else(condition = nrow(inundated_hospital) > 0, true = "inundated", false = "not inundated")
  
  this_hospital_inundation <- this_hospital |> mutate(inundation = inundated_or_not)
  
  return(this_hospital_inundation)
  
})
  
st_write(hospital_inundation_df, here("data/spatial/not_inundated_hospitals/not_inundated_hospitals.shp"))

```

Identify non-inundated EMS locations

```{r}

ems_sf <- st_read(here("data/spatial/QSC_QLD emergency service locations/Emergency_services_facilities.shp"))

#crop to brisbane lga bounding box
ems_sf_brisbane <- ems_sf |> 
  st_transform(crs = st_crs(flood_awareness)) |> 
  st_crop(st_bbox(flood_awareness)) |> 
  mutate(row_num = row_number())

#check the ems locations plot Ok
ggplot()+
  geom_sf(data = flood_awareness)+
  geom_sf(data = ems_sf_brisbane)


#split the ems service data

ems_split <- ems_sf_brisbane |> group_by(row_num) |> group_split()

#test function
this_ems <- ems_split[[1]]

#### Parallelise for speed ###

#define cores
cores <- parallel::detectCores()/2

#setup the session
future::plan(future::multisession, workers = cores)


ems_inundated <- 
  
  furrr::future_map(.x = ems_split, .f = \(this_ems){
    
    message("processing ems location ", this_ems$row_num , " / ", ems_sf_brisbane |> nrow())
  
    this_ems_intersect <- st_intersection(this_ems, flood_awareness)
    
    this_ems_classify <- this_ems |> 
      mutate(inundation = case_when(nrow(this_ems_intersect)>0 ~ "Inundated",
                                    TRUE ~ "Not inundated"))
    
    return(this_ems_classify)
    
  }) |> bind_rows()


ems_not_inundated <- ems_inundated |> filter(inundation == "Not inundated")

st_write(ems_not_inundated, here("data/spatial/not_inundated_ems/not_inundated_ems.shp"))

```

